#+STARTUP: hidestars

* ch13_String
** ex
*** 1.Smallest word and largest word
    #+BEGIN_SRC c
      #include <stdio.h>
      #include <string.h>

      #define SIZE 21

      void clean_str(char *s);
      int main(int argc, char *argv[])
      {
	char smallest[SIZE] = "";
	for (int i= 0; i < SIZE; ++i) {
	  smallest[i] = 'z';
	}

	char largest[SIZE] = "";
	char receive[SIZE] = "";
	printf("Enter word: ");
	while (  scanf("%s", receive) && strlen(receive) != 4) {
	  if (strcmp(receive, smallest) < 1) {
	    clean_str(smallest);
	    for (int i = 0; i < strlen(receive); ++i) {
	      smallest[i] = receive[i];
	    }
	  }
	  if (strcmp(receive, largest) > 1) {
	    clean_str(largest);
	    for (int i = 0; i < strlen(receive); ++i) {
	      largest[i] = receive[i];
	    }
	  }

	  printf("Enter word: ");
	}

	printf("\n");
	printf("Smallest word: %s\n", smallest);
	printf("Largest word: %s\n", largest);
	return 0;
      }

      void clean_str(char *s)
      {
	for (int i = 0; i < strlen(s); ++i) {
	  s[i] = ' ';
	}
      }


    #+END_SRC
    
    
*** 2.Reverse.c
    #+BEGIN_SRC c
      #include <stdio.h>
      #include <string.h>

      int main(int argc, char *argv[])
      {

	printf("%d\n", argc);
	for (int i = argc -1; i != 0; --i) {
	  printf("%s %d\n", *(argv + i), strlen(*(argv + i)));
    
	}
	return 0;
      }
    #+END_SRC
* ch17_Pointer
** 17.2
*** 17.2.2 malloc string function
   #+BEGIN_SRC c
     #include <stdio.h>
     #include <stdlib.h>
     #include <string.h>

     char *concat(const char *s1, const char *s2);

     int main(int argc, char *argv[])
     {
       char *s1 = "abc";
       char *s2 = "def";
       printf("%s\n", concat(s1, s2));
  
       return 0;
     }

     /* 
      ,* Load two strings, compute their size
      ,* malloc a space to concat two string
      ,* free it when used
      ,*/
     char *concat(const char *s1, const char *s2)
     {
       char *result;
       result = malloc(strlen(s1) + strlen(s2));

       if (result == NULL) {
	 printf("Error: malloc failed tin concat\n");
	 exit(EXIT_FAILURE);
       }
       strcpy(result, s1);
       strcat(result, s2);
       return result;
     }
   #+END_SRC
** 17.3
*** 17.3.1 malloc dynamic allocation array
    #+BEGIN_SRC c

      int *a;
      a = malloc(n * sizeof(int));

    #+END_SRC

*** 17.3.2 calloc dynamic allocation array
    #+BEGIN_SRC c

      a = calloc(n, sizeof(int));
      struct point {int x, y;} *p;
      p = calloc (1, sizeof(struct  point));

    #+END_SRC

*** 17.4 free it!
    free some allocation things

** 17.5 LINKER LIST
*** 17.5.1 declare node type

    #+BEGIN_SRC c

      sruct node{
	// data stored in the node
	int value;
	// pointer to the next node
	struct node *next;
      };

    #+END_SRC
*** 17.5.2 
